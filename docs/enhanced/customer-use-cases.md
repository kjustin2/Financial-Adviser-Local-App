# Customer Use Cases - $200k Investor Segment

## Executive Summary

This document outlines customer use cases for the enhanced financial adviser application targeting investors with approximately $200,000 in net worth. This segment represents "sub-HNWI" (High Net Worth Individual) investors who are well on their way to building wealth but require sophisticated tools to optimize their financial trajectory.

## Target Customer Profile

### Primary Demographics
- **Age Range**: 35-55 years old
- **Income**: $75,000 - $150,000 annually
- **Net Worth**: $150,000 - $300,000 (centered around $200k)
- **Life Stage**: Mid-career professionals, established families
- **Financial Knowledge**: Intermediate to advanced understanding of investments
- **Technology Comfort**: High comfort with digital financial tools

### Psychographic Profile
- **Investment Approach**: DIY-oriented but seeks professional-grade tools
- **Risk Tolerance**: Moderate to moderate-aggressive
- **Goals**: Wealth optimization, tax efficiency, retirement acceleration
- **Pain Points**: Complexity of managing multiple accounts, tax optimization, fee minimization
- **Preferred Communication**: Data-driven insights, actionable recommendations

## Primary Use Cases

### 1. Sarah - Mid-Career Professional Optimizing for Early Retirement
**Profile**: 42-year-old marketing director, $120k salary, $220k net worth
**Challenge**: Wants to retire at 55 but unsure if on track with complex portfolio across multiple accounts

#### Use Case Scenario:
- **Portfolio Complexity**: 401k, Roth IRA, taxable brokerage, HSA, stock options
- **Primary Need**: Consolidated view of all accounts with retirement projections
- **Key Features Used**:
  - Multi-account portfolio aggregation
  - Early retirement calculator with Monte Carlo simulations
  - Tax-loss harvesting opportunities across accounts
  - Asset location optimization (tax-efficient fund placement)
  - Catch-up contribution recommendations

#### Success Metrics:
- Identifies $2,400/year in tax savings through optimization
- Reduces portfolio fees by 0.3% annually
- Accelerates retirement timeline by 2 years through strategic rebalancing

### 2. Michael - High-Earning Professional Managing Tax Complexity
**Profile**: 38-year-old software engineer, $140k salary, $180k net worth, stock compensation
**Challenge**: Managing tax implications of RSUs, options, and optimizing high-income tax strategies

#### Use Case Scenario:
- **Income Complexity**: Base salary + RSUs + stock options + side consulting
- **Primary Need**: Tax-efficient investment strategy and timing optimization
- **Key Features Used**:
  - Stock option exercise timing calculator
  - Tax-loss harvesting with wash sale prevention
  - Backdoor Roth IRA conversion planning
  - Mega-backdoor Roth analysis
  - Alternative minimum tax (AMT) planning

#### Success Metrics:
- Saves $8,000 annually through optimal stock option timing
- Maximizes tax-advantaged account contributions
- Reduces effective tax rate by 3% through strategic planning

### 3. Jennifer & David - Dual-Income Family Balancing Multiple Goals
**Profile**: 41 & 44 years old, combined $160k income, $250k net worth, two teenagers
**Challenge**: Balancing college funding, retirement savings, and current family expenses

#### Use Case Scenario:
- **Competing Priorities**: 529 plans, retirement accounts, emergency fund, mortgage
- **Primary Need**: Goal prioritization and optimization across multiple objectives
- **Key Features Used**:
  - Multi-goal optimization engine
  - 529 vs. taxable investment analysis
  - College funding gap analysis
  - Family cash flow optimization
  - Insurance needs assessment

#### Success Metrics:
- Optimizes allocation across competing goals
- Identifies opportunity to increase retirement savings by $6,000/year
- Develops clear college funding strategy for both children

### 4. Robert - Pre-Retiree Catching Up on Savings
**Profile**: 52-year-old consultant, $110k income, $190k net worth, behind on retirement
**Challenge**: Maximizing catch-up contributions and optimizing final working years

#### Use Case Scenario:
- **Time Constraint**: 13 years until planned retirement
- **Primary Need**: Aggressive catch-up strategy with risk management
- **Key Features Used**:
  - Catch-up contribution maximization
  - Social Security optimization calculator
  - Healthcare cost planning
  - Bond ladder construction
  - Sequence of returns risk analysis

#### Success Metrics:
- Maximizes all catch-up contributions ($30,000+ annually)
- Develops risk-appropriate glide path for final working years
- Creates sustainable withdrawal strategy

### 5. Lisa - Divorced Professional Rebuilding Financial Foundation
**Profile**: 45-year-old healthcare administrator, $95k salary, $160k net worth post-divorce
**Challenge**: Rebuilding financial security while managing new single-income household

#### Use Case Scenario:
- **Fresh Start**: Recently divorced, managing finances independently
- **Primary Need**: Comprehensive financial health assessment and rebuilding plan
- **Key Features Used**:
  - Financial health scoring and improvement roadmap
  - Emergency fund optimization
  - Solo 401k vs. traditional IRA analysis
  - Estate planning updates
  - Risk tolerance reassessment

#### Success Metrics:
- Builds 6-month emergency fund within 18 months
- Optimizes retirement contributions for new situation
- Develops comprehensive financial independence plan

## Secondary Use Cases

### 6. Tech Professional with Crypto Holdings
**Profile**: 35-year-old developer with significant cryptocurrency investments
**Challenge**: Integrating crypto into overall portfolio strategy and tax planning

### 7. Small Business Owner with Variable Income
**Profile**: 46-year-old consultant with fluctuating income and SEP-IRA
**Challenge**: Managing retirement savings with irregular cash flow

### 8. Inheritance Recipient Seeking Optimization
**Profile**: 39-year-old teacher who inherited $80k, boosting net worth to $200k
**Challenge**: Integrating windfall into existing financial plan

## Enhanced Feature Requirements

### Advanced Portfolio Management
- **Multi-Account Aggregation**: Seamless integration across brokerages
- **Real-Time Rebalancing**: Automated rebalancing recommendations
- **Tax-Loss Harvesting**: Ongoing tax optimization opportunities
- **Asset Location Optimization**: Tax-efficient fund placement
- **Performance Attribution**: Detailed analysis of portfolio performance

### Sophisticated Planning Tools
- **Monte Carlo Simulations**: Retirement probability analysis
- **Goal Prioritization Engine**: Optimal allocation across multiple objectives
- **Tax Planning Integration**: Comprehensive tax strategy optimization
- **Estate Planning Tools**: Basic estate planning calculations
- **Insurance Analysis**: Life and disability insurance needs assessment

### Professional-Grade Analytics
- **Risk-Return Optimization**: Modern portfolio theory implementation
- **Scenario Analysis**: What-if modeling for major life changes
- **Benchmark Comparison**: Performance vs. appropriate benchmarks
- **Fee Analysis**: Comprehensive cost analysis across holdings
- **Alpha Generation**: Identification of outperformance opportunities

## Customer Journey Mapping

### Discovery Phase
- **Trigger**: Realization that current tools are insufficient for complexity
- **Research**: Comparison shopping for professional-grade tools
- **Evaluation**: Free trial or demo of advanced features

### Onboarding Phase
- **Account Setup**: Secure connection to multiple financial institutions
- **Data Import**: Historical transaction and holding data
- **Goal Setting**: Comprehensive financial objective establishment
- **Risk Assessment**: Detailed risk tolerance and capacity analysis

### Active Usage Phase
- **Daily Monitoring**: Portfolio performance and market updates
- **Monthly Reviews**: Progress toward goals and optimization opportunities
- **Quarterly Planning**: Strategic adjustments and rebalancing
- **Annual Assessment**: Comprehensive financial health evaluation

### Retention Factors
- **Measurable ROI**: Clear demonstration of value through savings/gains
- **Time Savings**: Automation of complex financial tasks
- **Professional Confidence**: Access to institutional-quality tools
- **Customization**: Tailored recommendations for unique situations

## Success Metrics and KPIs

### Financial Outcomes
- **Net Worth Growth**: 8-12% annually (above market average)
- **Tax Savings**: $2,000-$5,000 annually per user
- **Fee Reduction**: 0.2-0.5% annually through optimization
- **Goal Achievement**: 85% of users meeting savings targets

### User Engagement
- **Monthly Active Users**: 80%+ of paid subscribers
- **Feature Utilization**: 6+ features used monthly
- **Session Duration**: 15+ minutes average
- **Return Frequency**: 3+ times per week

### Business Metrics
- **Customer Acquisition Cost**: <$200
- **Customer Lifetime Value**: $2,000+
- **Net Promoter Score**: 70+
- **Churn Rate**: <5% monthly

## Technical User Stories & API Requirements

### User Story 1: Real-Time Portfolio Optimization
**As a** mid-career professional with $200k+ net worth  
**I want** to optimize my portfolio allocation in real-time  
**So that** I can maximize returns while managing risk appropriately

#### Technical Requirements
```typescript
// API Endpoint: POST /api/v1/portfolio/optimize
interface OptimizationRequest {
  portfolio_id: string;
  objective: 'max_sharpe' | 'min_volatility' | 'max_return' | 'target_risk';
  constraints: {
    min_weight?: number;
    max_weight?: number;
    sector_limits?: Record<string, [number, number]>;
    esg_score_min?: number;
    turnover_limit?: number;
  };
  rebalance_threshold?: number;
}

interface OptimizationResponse {
  optimization_id: string;
  current_allocation: Record<string, number>;
  optimal_allocation: Record<string, number>;
  expected_return: number;
  volatility: number;
  sharpe_ratio: number;
  efficient_frontier: Array<{
    return: number;
    volatility: number;
    sharpe_ratio: number;
  }>;
  rebalancing_trades: Array<{
    symbol: string;
    action: 'buy' | 'sell';
    shares: number;
    dollar_amount: number;
    reason: string;
  }>;
  estimated_improvement: {
    return_improvement: number;
    risk_reduction: number;
    cost_savings: number;
  };
}
```

#### Implementation Details
```python
# backend/app/api/v1/endpoints/optimization.py
@router.post("/optimize", response_model=OptimizationResponse)
async def optimize_portfolio(
    request: OptimizationRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Optimize portfolio allocation using modern portfolio theory"""
    
    # Validate portfolio ownership
    portfolio = await get_portfolio_by_id(db, request.portfolio_id, current_user.id)
    if not portfolio:
        raise HTTPException(status_code=404, detail="Portfolio not found")
    
    # Get current holdings
    holdings = await get_portfolio_holdings(db, portfolio.id)
    
    # Initialize optimizer
    optimizer = PortfolioOptimizer()
    
    # Run optimization
    result = await optimizer.optimize_portfolio(
        portfolio_id=portfolio.id,
        assets=holdings,
        constraints=OptimizationConstraints(**request.constraints),
        objective=request.objective
    )
    
    # Calculate rebalancing trades
    trades = await calculate_rebalancing_trades(
        current_holdings=holdings,
        target_allocation=result.weights,
        threshold=request.rebalance_threshold or 0.05
    )
    
    return OptimizationResponse(
        optimization_id=result.id,
        current_allocation=portfolio.current_allocation,
        optimal_allocation=dict(zip([h.symbol for h in holdings], result.weights)),
        expected_return=result.expected_return,
        volatility=result.volatility,
        sharpe_ratio=result.sharpe_ratio,
        efficient_frontier=result.efficient_frontier,
        rebalancing_trades=trades,
        estimated_improvement=result.improvement_metrics
    )
```

### User Story 2: Tax-Loss Harvesting Automation
**As a** high-earning professional  
**I want** to automatically identify tax-loss harvesting opportunities  
**So that** I can minimize my tax burden and improve after-tax returns

#### Technical Requirements
```typescript
// API Endpoint: GET /api/v1/tax/loss-harvesting
interface TaxLossHarvestingRequest {
  portfolio_id: string;
  tax_rate_short: number;
  tax_rate_long: number;
  min_loss_threshold: number;
  include_wash_sale_analysis: boolean;
}

interface TaxLossOpportunity {
  holding_id: string;
  symbol: string;
  current_price: number;
  cost_basis: number;
  shares: number;
  unrealized_loss: number;
  tax_savings: number;
  wash_sale_risk: 'low' | 'medium' | 'high';
  replacement_options: Array<{
    symbol: string;
    name: string;
    correlation: number;
    expense_ratio: number;
    suitability_score: number;
  }>;
  holding_period: number; // days
  lot_details: Array<{
    lot_id: string;
    purchase_date: string;
    shares: number;
    cost_basis: number;
  }>;
  recommended_action: {
    action: 'harvest_now' | 'wait_wash_sale' | 'monitor' | 'hold';
    reason: string;
    timing: string;
  };
}

interface TaxLossHarvestingResponse {
  opportunities: TaxLossOpportunity[];
  total_potential_savings: number;
  total_harvestable_loss: number;
  summary: {
    immediate_opportunities: number;
    wash_sale_delayed: number;
    monitoring_required: number;
  };
}
```

#### Implementation Details
```python
# backend/app/api/v1/endpoints/tax_optimizer.py
@router.get("/loss-harvesting", response_model=TaxLossHarvestingResponse)
async def get_tax_loss_opportunities(
    request: TaxLossHarvestingRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """Identify tax-loss harvesting opportunities"""
    
    tax_optimizer = TaxOptimizer()
    
    opportunities = await tax_optimizer.analyze_tax_loss_opportunities(
        user_id=current_user.id,
        portfolio_id=request.portfolio_id,
        tax_rate_short=request.tax_rate_short,
        tax_rate_long=request.tax_rate_long
    )
    
    # Filter by minimum loss threshold
    filtered_opportunities = [
        opp for opp in opportunities 
        if opp.unrealized_loss >= request.min_loss_threshold
    ]
    
    # Calculate summary statistics
    total_savings = sum(opp.tax_savings for opp in filtered_opportunities)
    total_loss = sum(opp.unrealized_loss for opp in filtered_opportunities)
    
    summary = {
        'immediate_opportunities': len([
            opp for opp in filtered_opportunities 
            if opp.recommended_action.action == 'harvest_now'
        ]),
        'wash_sale_delayed': len([
            opp for opp in filtered_opportunities 
            if opp.recommended_action.action == 'wait_wash_sale'
        ]),
        'monitoring_required': len([
            opp for opp in filtered_opportunities 
            if opp.recommended_action.action == 'monitor'
        ])
    }
    
    return TaxLossHarvestingResponse(
        opportunities=filtered_opportunities,
        total_potential_savings=total_savings,
        total_harvestable_loss=total_loss,
        summary=summary
    )
```

### User Story 3: Real-Time Market Data Integration
**As a** sophisticated investor  
**I want** to receive real-time market data and portfolio updates  
**So that** I can make informed decisions based on current market conditions

#### Technical Requirements
```typescript
// WebSocket Connection: ws://localhost:8000/ws/market-data
interface MarketDataSubscription {
  type: 'subscribe' | 'unsubscribe';
  symbols: string[];
  data_types: Array<'price' | 'quote' | 'volume' | 'news'>;
}

interface MarketDataUpdate {
  type: 'price_update' | 'quote_update' | 'volume_update' | 'news_update';
  symbol: string;
  timestamp: string;
  data: {
    price?: number;
    change?: number;
    change_percent?: number;
    volume?: number;
    bid?: number;
    ask?: number;
    market_cap?: number;
    pe_ratio?: number;
  };
}

interface PortfolioUpdate {
  type: 'portfolio_update';
  portfolio_id: string;
  timestamp: string;
  changes: {
    total_value: number;
    daily_change: number;
    daily_change_percent: number;
    holdings_updated: Array<{
      symbol: string;
      new_value: number;
      change: number;
      change_percent: number;
    }>;
  };
}
```

#### WebSocket Implementation
```python
# backend/app/api/v1/websocket.py
@router.websocket("/ws/market-data")
async def market_data_websocket(
    websocket: WebSocket,
    token: str = Query(...),
    db: Session = Depends(get_db)
):
    """WebSocket endpoint for real-time market data"""
    
    # Authenticate user
    user = await authenticate_websocket_user(token, db)
    if not user:
        await websocket.close(code=1008, reason="Invalid token")
        return
    
    await websocket.accept()
    
    # Register connection
    user_id = str(user.id)
    market_data_service.register_connection(user_id, websocket)
    
    try:
        while True:
            # Receive subscription requests
            data = await websocket.receive_json()
            
            if data['type'] == 'subscribe':
                await market_data_service.subscribe_user(
                    user_id, 
                    data['symbols'],
                    data.get('data_types', ['price'])
                )
            elif data['type'] == 'unsubscribe':
                await market_data_service.unsubscribe_user(
                    user_id,
                    data['symbols']
                )
            
    except WebSocketDisconnect:
        # Clean up connection
        market_data_service.unregister_connection(user_id)
        await market_data_service.cleanup_user_subscriptions(user_id)
```

### User Story 4: ML-Powered Investment Recommendations
**As a** investor with complex financial goals  
**I want** to receive personalized investment recommendations  
**So that** I can optimize my portfolio based on my unique situation

#### Technical Requirements
```typescript
// API Endpoint: GET /api/v1/recommendations
interface RecommendationRequest {
  portfolio_id: string;
  recommendation_types: Array<'allocation' | 'security' | 'tax' | 'goal' | 'risk'>;
  risk_tolerance: 'conservative' | 'moderate' | 'aggressive';
  time_horizon: 'short' | 'medium' | 'long';
  include_explanations: boolean;
}

interface Recommendation {
  id: string;
  type: 'allocation_adjustment' | 'security_replacement' | 'tax_optimization' | 'goal_adjustment' | 'risk_management';
  title: string;
  description: string;
  confidence_score: number; // 0-1
  impact_score: number; // 0-100
  expected_benefit: number; // dollar amount
  implementation_difficulty: 'easy' | 'medium' | 'hard';
  time_horizon: 'immediate' | 'short_term' | 'medium_term' | 'long_term';
  category: string;
  priority: 'high' | 'medium' | 'low';
  explanation: {
    reasoning: string;
    supporting_data: Record<string, any>;
    alternatives: string[];
    risks: string[];
  };
  implementation_steps: Array<{
    step: number;
    description: string;
    estimated_time: string;
    required_actions: string[];
  }>;
}

interface RecommendationResponse {
  recommendations: Recommendation[];
  summary: {
    total_recommendations: number;
    high_priority: number;
    medium_priority: number;
    low_priority: number;
    total_potential_benefit: number;
  };
  user_profile: {
    risk_cluster: string;
    investment_style: string;
    primary_goals: string[];
    constraints: string[];
  };
}
```

#### ML Engine Implementation
```python
# backend/app/services/recommendation_engine.py
class RecommendationEngine:
    def __init__(self):
        self.models = {
            'user_clustering': self.load_model('user_clustering.pkl'),
            'performance_prediction': self.load_model('performance_prediction.pkl'),
            'risk_assessment': self.load_model('risk_assessment.pkl')
        }
    
    async def generate_recommendations(
        self,
        user_id: str,
        portfolio_id: str,
        request: RecommendationRequest
    ) -> RecommendationResponse:
        """Generate personalized investment recommendations"""
        
        # Get user profile and portfolio data
        user_profile = await self.get_user_profile(user_id)
        portfolio = await self.get_portfolio_analysis(portfolio_id)
        market_context = await self.get_market_context()
        
        # Determine user cluster
        user_cluster = self.classify_user(user_profile)
        
        recommendations = []
        
        # Generate allocation recommendations
        if 'allocation' in request.recommendation_types:
            allocation_recs = await self.generate_allocation_recommendations(
                user_profile, portfolio, user_cluster
            )
            recommendations.extend(allocation_recs)
        
        # Generate security recommendations
        if 'security' in request.recommendation_types:
            security_recs = await self.generate_security_recommendations(
                user_profile, portfolio, user_cluster, market_context
            )
            recommendations.extend(security_recs)
        
        # Generate tax recommendations
        if 'tax' in request.recommendation_types:
            tax_recs = await self.generate_tax_recommendations(
                user_profile, portfolio
            )
            recommendations.extend(tax_recs)
        
        # Sort by priority and impact
        recommendations.sort(
            key=lambda x: (x.priority_score, x.impact_score), 
            reverse=True
        )
        
        # Generate summary
        summary = self.generate_summary(recommendations)
        
        return RecommendationResponse(
            recommendations=recommendations,
            summary=summary,
            user_profile=user_cluster
        )
```

### User Story 5: Advanced Risk Analytics
**As a** sophisticated investor  
**I want** to analyze portfolio risk metrics in real-time  
**So that** I can make informed decisions about risk management

#### Technical Requirements
```typescript
// API Endpoint: GET /api/v1/analytics/risk
interface RiskAnalysisRequest {
  portfolio_id: string;
  analysis_period: '1M' | '3M' | '6M' | '1Y' | '3Y' | '5Y';
  benchmark_symbol?: string;
  confidence_levels: number[]; // e.g., [0.95, 0.99] for VaR
  include_stress_tests: boolean;
  include_scenario_analysis: boolean;
}

interface RiskAnalysisResponse {
  portfolio_id: string;
  analysis_date: string;
  risk_metrics: {
    volatility: number;
    beta: number;
    sharpe_ratio: number;
    sortino_ratio: number;
    max_drawdown: number;
    calmar_ratio: number;
    information_ratio: number;
    tracking_error: number;
  };
  value_at_risk: Record<string, number>; // confidence level -> VaR
  expected_shortfall: Record<string, number>; // confidence level -> ES
  correlation_matrix: Record<string, Record<string, number>>;
  sector_concentration: Record<string, number>;
  factor_exposures: {
    market: number;
    size: number;
    value: number;
    momentum: number;
    quality: number;
    volatility: number;
  };
  stress_tests?: Array<{
    scenario: string;
    description: string;
    portfolio_impact: number;
    impact_percentage: number;
    probability: number;
  }>;
  scenario_analysis?: Array<{
    scenario: string;
    market_conditions: Record<string, number>;
    portfolio_return: number;
    risk_metrics: Record<string, number>;
  }>;
}
```

#### Risk Analytics Implementation
```python
# backend/app/services/risk_analyzer.py
class RiskAnalyzer:
    def __init__(self):
        self.risk_models = {
            'var': ValueAtRiskModel(),
            'expected_shortfall': ExpectedShortfallModel(),
            'stress_test': StressTestModel()
        }
    
    async def analyze_portfolio_risk(
        self,
        portfolio_id: str,
        request: RiskAnalysisRequest
    ) -> RiskAnalysisResponse:
        """Comprehensive portfolio risk analysis"""
        
        # Get portfolio data
        portfolio = await self.get_portfolio_with_history(
            portfolio_id, 
            request.analysis_period
        )
        
        # Get benchmark data if specified
        benchmark_data = None
        if request.benchmark_symbol:
            benchmark_data = await self.get_benchmark_data(
                request.benchmark_symbol,
                request.analysis_period
            )
        
        # Calculate basic risk metrics
        risk_metrics = self.calculate_risk_metrics(portfolio, benchmark_data)
        
        # Calculate VaR and Expected Shortfall
        var_results = {}
        es_results = {}
        
        for confidence_level in request.confidence_levels:
            var_results[str(confidence_level)] = self.risk_models['var'].calculate(
                portfolio.returns, confidence_level
            )
            es_results[str(confidence_level)] = self.risk_models['expected_shortfall'].calculate(
                portfolio.returns, confidence_level
            )
        
        # Calculate correlation matrix
        correlation_matrix = self.calculate_correlation_matrix(portfolio.holdings)
        
        # Analyze sector concentration
        sector_concentration = self.analyze_sector_concentration(portfolio.holdings)
        
        # Factor exposure analysis
        factor_exposures = await self.calculate_factor_exposures(portfolio)
        
        # Stress testing
        stress_tests = None
        if request.include_stress_tests:
            stress_tests = await self.run_stress_tests(portfolio)
        
        # Scenario analysis
        scenario_analysis = None
        if request.include_scenario_analysis:
            scenario_analysis = await self.run_scenario_analysis(portfolio)
        
        return RiskAnalysisResponse(
            portfolio_id=portfolio_id,
            analysis_date=datetime.now().isoformat(),
            risk_metrics=risk_metrics,
            value_at_risk=var_results,
            expected_shortfall=es_results,
            correlation_matrix=correlation_matrix,
            sector_concentration=sector_concentration,
            factor_exposures=factor_exposures,
            stress_tests=stress_tests,
            scenario_analysis=scenario_analysis
        )
```

## Database Schema Extensions

### Enhanced User Profile Table
```sql
-- Extended user profiles for ML recommendations
CREATE TABLE user_profiles_extended (
    user_id UUID PRIMARY KEY REFERENCES users(id),
    risk_cluster VARCHAR(20),
    investment_style VARCHAR(50),
    behavioral_profile JSONB,
    financial_goals JSONB,
    constraints JSONB,
    tax_situation JSONB,
    life_stage VARCHAR(20),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- User interaction tracking for ML
CREATE TABLE user_interactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    interaction_type VARCHAR(50) NOT NULL,
    context JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    session_id UUID
);

-- ML model performance tracking
CREATE TABLE ml_model_performance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_name VARCHAR(100) NOT NULL,
    model_version VARCHAR(20) NOT NULL,
    performance_metrics JSONB,
    evaluation_date DATE NOT NULL,
    data_period_start DATE,
    data_period_end DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

## API Authentication & Security

### Enhanced JWT Token Structure
```python
# backend/app/core/security.py
class EnhancedJWTManager:
    def create_access_token(self, user_id: str, permissions: List[str]) -> str:
        """Create enhanced JWT token with detailed permissions"""
        
        payload = {
            'sub': user_id,
            'permissions': permissions,
            'token_type': 'access',
            'exp': datetime.utcnow() + timedelta(hours=1),
            'iat': datetime.utcnow(),
            'jti': str(uuid.uuid4()),
            'session_id': str(uuid.uuid4())
        }
        
        return jwt.encode(
            payload, 
            settings.SECRET_KEY, 
            algorithm=settings.ALGORITHM
        )
    
    def verify_permission(self, token: str, required_permission: str) -> bool:
        """Verify user has required permission"""
        try:
            payload = jwt.decode(
                token, 
                settings.SECRET_KEY, 
                algorithms=[settings.ALGORITHM]
            )
            return required_permission in payload.get('permissions', [])
        except JWTError:
            return False
```

## Performance Optimization

### Caching Strategy
```python
# backend/app/services/cache_manager.py
class CacheManager:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.cache_ttl = {
            'market_data': 60,  # 1 minute
            'portfolio_optimization': 300,  # 5 minutes
            'risk_analysis': 600,  # 10 minutes
            'recommendations': 1800,  # 30 minutes
        }
    
    async def get_cached_optimization(
        self, 
        portfolio_id: str, 
        constraints_hash: str
    ) -> Optional[OptimizationResult]:
        """Get cached optimization result"""
        
        cache_key = f"optimization:{portfolio_id}:{constraints_hash}"
        cached_data = await self.redis_client.get(cache_key)
        
        if cached_data:
            return OptimizationResult.from_json(cached_data)
        
        return None
    
    async def cache_optimization(
        self, 
        portfolio_id: str, 
        constraints_hash: str, 
        result: OptimizationResult
    ):
        """Cache optimization result"""
        
        cache_key = f"optimization:{portfolio_id}:{constraints_hash}"
        await self.redis_client.setex(
            cache_key,
            self.cache_ttl['portfolio_optimization'],
            result.to_json()
        )
```

This enhanced customer-centric approach ensures the platform delivers measurable value to sophisticated investors while maintaining the local-first architecture that provides security and control over sensitive financial data. The technical implementation provides professional-grade APIs and real-time capabilities that match institutional-quality financial software.